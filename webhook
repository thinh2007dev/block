-- Webhook Blocker v4.0 - MOBILE & PC COMPATIBLE
-- T·ªëi ∆∞u cho m·ªçi executor (Solara, Wave, Arceus X, Delta...)

if getgenv().WEBHOOK_BLOCKER_V4_LOADED then
    return
end

getgenv().WEBHOOK_BLOCKER_V4_LOADED = true

local ENABLE_LOGS = false -- T·∫Øt log ƒë·ªÉ tr√°nh lag tr√™n mobile

local function log(...)
    if ENABLE_LOGS then
        print('[WH Block]', ...)
    end
end

log('üöÄ Kh·ªüi ƒë·ªông Webhook Blocker v4.0 (Mobile Compatible)...')

-- Danh s√°ch webhook domains c·∫ßn block
local webhook_domains = {
    "discord.com/api/webhooks",
    "discordapp.com/api/webhooks",
    "discord.gg/api/webhooks",
    "ptb.discord.com/api/webhooks",
    "canary.discord.com/api/webhooks",
    "hooks.slack.com/services",
    "hooks.slack.com/workflows",
    "webhook.site",
    "requestcatcher.com"
}

-- Ki·ªÉm tra URL c√≥ ph·∫£i webhook kh√¥ng
local function is_webhook(url)
    if not url or type(url) ~= "string" then
        return false
    end
    
    local url_lower = url:lower()
    
    for _, domain in ipairs(webhook_domains) do
        if url_lower:find(domain, 1, true) then
            return true
        end
    end
    
    return false
end

-- Response gi·∫£ ƒë·ªÉ tr√°nh crash
local function create_fake_response()
    return {
        Success = true,
        StatusCode = 200,
        StatusMessage = "OK",
        Body = '{"success":true,"message":"Request blocked by webhook blocker"}',
        Headers = {
            ["content-type"] = "application/json",
            ["x-blocked-by"] = "webhook-blocker-v4"
        }
    }
end

-- ========== HOOK REQUEST FUNCTIONS ==========
local function hook_request_functions()
    -- T√¨m request function (h·ªó tr·ª£ nhi·ªÅu executor)
    local original_request = 
        request or 
        http_request or 
        (http and http.request) or 
        (syn and syn.request) or
        (fluxus and fluxus.request) or
        (getgenv().request)
    
    if not original_request then
        log('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y request function')
        return false
    end
    
    local function safe_request(options)
        -- Ki·ªÉm tra options
        if type(options) == "table" and options.Url then
            if is_webhook(options.Url) then
                warn('üõë [Webhook Blocked]:', options.Url)
                return create_fake_response()
            end
        elseif type(options) == "string" then
            if is_webhook(options) then
                warn('üõë [Webhook Blocked]:', options)
                return create_fake_response()
            end
        end
        
        -- Cho qua n·∫øu kh√¥ng ph·∫£i webhook
        return original_request(options)
    end
    
    -- Override t·∫•t c·∫£ c√°c bi·∫øn th·ªÉ c·ªßa request
    local request_names = {
        "request",
        "http_request", 
        "http.request",
        "syn.request",
        "fluxus.request"
    }
    
    for _, name in ipairs(request_names) do
        local parts = string.split(name, ".")
        if #parts == 1 then
            if getgenv()[name] then
                getgenv()[name] = safe_request
            end
        elseif #parts == 2 then
            local parent = getgenv()[parts[1]]
            if parent and parent[parts[2]] then
                parent[parts[2]] = safe_request
            end
        end
    end
    
    log('‚úì ƒê√£ hook request functions')
    return true
end

-- ========== HOOK WEBSOCKET ==========
local function hook_websocket()
    local ws_found = false
    
    -- Syn WebSocket
    if syn and syn.websocket and syn.websocket.connect then
        local original_ws = syn.websocket.connect
        
        syn.websocket.connect = function(url)
            if is_webhook(url) then
                warn('üõë [WebSocket Blocked]:', url)
                
                -- Mock websocket object
                return {
                    Send = function() end,
                    Close = function() end,
                    OnMessage = {Connect = function() return {Disconnect = function() end} end},
                    OnClose = {Connect = function() return {Disconnect = function() end} end}
                }
            end
            
            return original_ws(url)
        end
        
        ws_found = true
        log('‚úì ƒê√£ hook Syn WebSocket')
    end
    
    -- WebSocket library (n·∫øu c√≥)
    if getgenv().WebSocket and getgenv().WebSocket.connect then
        local original_ws = getgenv().WebSocket.connect
        
        getgenv().WebSocket.connect = function(url)
            if is_webhook(url) then
                warn('üõë [WebSocket Blocked]:', url)
                return {
                    Send = function() end,
                    Close = function() end,
                    OnMessage = {Connect = function() return {Disconnect = function() end} end}
                }
            end
            
            return original_ws(url)
        end
        
        ws_found = true
        log('‚úì ƒê√£ hook WebSocket library')
    end
    
    if not ws_found then
        log('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y WebSocket functions')
    end
    
    return ws_found
end

-- ========== KH·ªûI T·∫†O ==========
local success, err = pcall(function()
    local request_hooked = hook_request_functions()
    local websocket_hooked = hook_websocket()
    
    if request_hooked or websocket_hooked then
        log('‚úÖ Webhook Blocker v4.0 ƒë√£ k√≠ch ho·∫°t')
        log('üõ°Ô∏è ƒêang b·∫£o v·ªá kh·ªèi webhook leaks')
    else
        warn('‚ö†Ô∏è Webhook Blocker: Kh√¥ng hook ƒë∆∞·ª£c function n√†o')
    end
end)

if not success then
    warn('‚ùå [Webhook Blocker] L·ªói kh·ªüi t·∫°o:', err)
end

-- Th√¥ng b√°o k√≠ch ho·∫°t (t√πy ch·ªçn)
if game:IsLoaded() then
    task.spawn(function()
        local StarterGui = game:GetService("StarterGui")
        pcall(function()
            StarterGui:SetCore("SendNotification", {
                Title = "üõ°Ô∏è Webhook Blocker",
                Text = "v4.0 ƒë√£ k√≠ch ho·∫°t!",
                Duration = 3
            })
        end)
    end)
end
